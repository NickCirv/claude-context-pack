/**
 * generator.js — generates .claudeignore and CLAUDE.md template
 */

import fs from 'fs'
import path from 'path'

/**
 * Generate .claudeignore content from analysis suggestions.
 */
export function generateClaudeIgnore(analysis, scanResult) {
  const lines = [
    '# .claudeignore — generated by claude-context-pack',
    '# Controls what Claude Code sees in this project.',
    '# Syntax is identical to .gitignore.',
    '',
  ]

  // Group suggestions by category
  const grouped = {}
  for (const s of analysis.suggestions) {
    if (!grouped[s.category]) grouped[s.category] = []
    grouped[s.category].push(s)
  }

  const categoryLabels = {
    dependencies: 'Dependencies',
    build: 'Build Output',
    coverage: 'Test Coverage',
    python: 'Python',
    lockfiles: 'Lock Files',
    logs: 'Logs',
    ide: 'IDE / Editor',
    os: 'OS Files',
    test: 'Test Artifacts',
    cache: 'Cache / Temp',
  }

  for (const [cat, slist] of Object.entries(grouped)) {
    lines.push(`# ${categoryLabels[cat] || cat}`)
    for (const s of slist) {
      lines.push(`${s.pattern}  # ${s.reason}`)
    }
    lines.push('')
  }

  // Add large file section if any
  if (analysis.largeFiles.length > 0) {
    lines.push('# Large files (>10KB) — review and uncomment as needed')
    for (const f of analysis.largeFiles.slice(0, 10)) {
      const tokens = f.tokens.toLocaleString()
      lines.push(`# ${f.relPath}  # ~${tokens} tokens`)
    }
    lines.push('')
  }

  return lines.join('\n')
}

/**
 * Generate a CLAUDE.md template tailored to the project.
 */
export function generateClaudeMd(scanResult, analysis) {
  const { files, rootDir } = scanResult

  // Detect tech stack from file extensions and known files
  const stack = detectStack(files, rootDir)

  // Find existing CLAUDE.md
  const hasExisting = fs.existsSync(path.join(rootDir, 'CLAUDE.md'))

  const sections = []

  sections.push(`# ${path.basename(rootDir)}`)
  sections.push('')
  sections.push('<!-- Generated by claude-context-pack. Customize for your project. -->')
  sections.push('')

  // Project overview
  sections.push('## Project Overview')
  sections.push('')
  sections.push('> One paragraph describing what this project does and its purpose.')
  sections.push('')

  // Stack
  if (stack.length > 0) {
    sections.push('## Tech Stack')
    sections.push('')
    for (const item of stack) {
      sections.push(`- **${item.name}**: ${item.note}`)
    }
    sections.push('')
  }

  // Architecture
  sections.push('## Architecture')
  sections.push('')
  sections.push('> Describe key directories, entry points, and how pieces connect.')
  sections.push('')

  // Key files
  const keyFiles = getKeyFiles(files, rootDir)
  if (keyFiles.length > 0) {
    sections.push('## Key Files')
    sections.push('')
    for (const f of keyFiles) {
      sections.push(`- \`${f.relPath}\` — ${f.note}`)
    }
    sections.push('')
  }

  // Commands
  sections.push('## Common Commands')
  sections.push('')
  const commands = detectCommands(files, rootDir)
  for (const cmd of commands) {
    sections.push(`\`\`\`bash`)
    sections.push(`${cmd.command}  # ${cmd.note}`)
    sections.push(`\`\`\``)
    sections.push('')
  }
  if (commands.length === 0) {
    sections.push('```bash')
    sections.push('# Add your common commands here')
    sections.push('```')
    sections.push('')
  }

  // Conventions
  sections.push('## Conventions')
  sections.push('')
  sections.push('> Coding standards, naming patterns, and rules for this project.')
  sections.push('')
  sections.push('- ...')
  sections.push('')

  // Context notes
  sections.push('## Context Notes for Claude')
  sections.push('')
  sections.push('> What Claude needs to know that isn\'t obvious from the code.')
  sections.push('')
  sections.push('- ...')
  sections.push('')

  return sections.join('\n')
}

/**
 * Detect likely tech stack from files present.
 */
function detectStack(files, rootDir) {
  const stack = []
  const fileNames = new Set(files.map(f => f.name))
  const exts = new Set(files.map(f => f.ext))
  const hasPkg = fileNames.has('package.json')

  // Read package.json deps if available
  let deps = {}
  try {
    const pkg = JSON.parse(fs.readFileSync(path.join(rootDir, 'package.json'), 'utf8'))
    deps = { ...(pkg.dependencies || {}), ...(pkg.devDependencies || {}) }
  } catch { /* ok */ }

  if (deps['next']) stack.push({ name: 'Next.js', note: 'React framework' })
  else if (deps['react']) stack.push({ name: 'React', note: 'UI library' })
  if (deps['vue'] || deps['nuxt']) stack.push({ name: 'Vue/Nuxt', note: 'Vue framework' })
  if (deps['svelte'] || deps['@sveltejs/kit']) stack.push({ name: 'SvelteKit', note: 'Svelte framework' })
  if (deps['express']) stack.push({ name: 'Express', note: 'Node.js web server' })
  if (deps['fastify']) stack.push({ name: 'Fastify', note: 'Node.js web server' })
  if (deps['typescript'] || exts.has('.ts') || exts.has('.tsx')) stack.push({ name: 'TypeScript', note: 'typed JavaScript' })
  if (deps['tailwindcss']) stack.push({ name: 'Tailwind CSS', note: 'utility-first CSS' })
  if (deps['prisma'] || deps['@prisma/client']) stack.push({ name: 'Prisma', note: 'ORM + database' })
  if (deps['drizzle-orm']) stack.push({ name: 'Drizzle', note: 'TypeScript ORM' })
  if (deps['stripe']) stack.push({ name: 'Stripe', note: 'payments' })
  if (deps['openai'] || deps['@anthropic-ai/sdk']) stack.push({ name: 'AI SDK', note: 'LLM integration' })

  if (hasPkg && stack.length === 0) stack.push({ name: 'Node.js', note: 'JavaScript runtime' })

  if (fileNames.has('requirements.txt') || fileNames.has('pyproject.toml')) {
    stack.push({ name: 'Python', note: 'check requirements.txt for deps' })
  }
  if (fileNames.has('Cargo.toml')) stack.push({ name: 'Rust', note: 'Cargo.toml for deps' })
  if (fileNames.has('go.mod')) stack.push({ name: 'Go', note: 'go.mod for deps' })
  if (fileNames.has('composer.json')) stack.push({ name: 'PHP/Composer', note: 'see composer.json' })
  if (fileNames.has('Gemfile')) stack.push({ name: 'Ruby', note: 'Gemfile for deps' })
  if (fileNames.has('pubspec.yaml')) stack.push({ name: 'Flutter/Dart', note: 'see pubspec.yaml' })

  return stack
}

/**
 * Identify key files worth mentioning in CLAUDE.md.
 */
function getKeyFiles(files, rootDir) {
  const keyPatterns = [
    { name: 'index.js', note: 'main entry point' },
    { name: 'index.ts', note: 'main entry point' },
    { name: 'main.js', note: 'application entry' },
    { name: 'main.ts', note: 'application entry' },
    { name: 'app.js', note: 'application root' },
    { name: 'app.ts', note: 'application root' },
    { name: 'server.js', note: 'HTTP server' },
    { name: 'server.ts', note: 'HTTP server' },
    { name: 'next.config.js', note: 'Next.js config' },
    { name: 'next.config.ts', note: 'Next.js config' },
    { name: 'vite.config.ts', note: 'Vite config' },
    { name: 'tailwind.config.js', note: 'Tailwind config' },
    { name: 'tailwind.config.ts', note: 'Tailwind config' },
    { name: 'schema.prisma', note: 'database schema' },
    { name: 'drizzle.config.ts', note: 'Drizzle config' },
    { name: '.env.example', note: 'required environment variables' },
    { name: 'docker-compose.yml', note: 'Docker services' },
    { name: 'Makefile', note: 'common tasks' },
  ]

  const found = []
  const fileMap = new Map(files.map(f => [f.name, f]))

  for (const kp of keyPatterns) {
    if (fileMap.has(kp.name)) {
      found.push({ relPath: fileMap.get(kp.name).relPath, note: kp.note })
    }
  }

  return found.slice(0, 10)
}

/**
 * Detect common development commands from project files.
 */
function detectCommands(files, rootDir) {
  const commands = []
  const fileNames = new Set(files.map(f => f.name))

  // Node.js
  if (fileNames.has('package.json')) {
    try {
      const pkg = JSON.parse(fs.readFileSync(path.join(rootDir, 'package.json'), 'utf8'))
      const scripts = pkg.scripts || {}
      if (scripts.dev) commands.push({ command: 'npm run dev', note: 'start dev server' })
      if (scripts.build) commands.push({ command: 'npm run build', note: 'production build' })
      if (scripts.test) commands.push({ command: 'npm test', note: 'run tests' })
      if (scripts.lint) commands.push({ command: 'npm run lint', note: 'lint code' })
    } catch { /* ok */ }
  }

  // Python
  if (fileNames.has('requirements.txt')) {
    commands.push({ command: 'pip install -r requirements.txt', note: 'install deps' })
    commands.push({ command: 'python main.py', note: 'run app (update path)' })
  }
  if (fileNames.has('Makefile')) {
    commands.push({ command: 'make help', note: 'see available make targets' })
  }
  if (fileNames.has('docker-compose.yml') || fileNames.has('docker-compose.yaml')) {
    commands.push({ command: 'docker compose up', note: 'start all services' })
  }

  return commands.slice(0, 6)
}

/**
 * Write files to disk with overwrite protection.
 */
export function writeFiles(rootDir, { claudeignore, claudeMd }, options = {}) {
  const { overwrite = false } = options
  const written = []
  const skipped = []

  const claudeignorePath = path.join(rootDir, '.claudeignore')
  const claudeMdPath = path.join(rootDir, 'CLAUDE.md')

  if (claudeignore) {
    if (!fs.existsSync(claudeignorePath) || overwrite) {
      fs.writeFileSync(claudeignorePath, claudeignore, 'utf8')
      written.push('.claudeignore')
    } else {
      skipped.push('.claudeignore')
    }
  }

  if (claudeMd) {
    if (!fs.existsSync(claudeMdPath) || overwrite) {
      fs.writeFileSync(claudeMdPath, claudeMd, 'utf8')
      written.push('CLAUDE.md')
    } else {
      skipped.push('CLAUDE.md')
    }
  }

  return { written, skipped }
}
